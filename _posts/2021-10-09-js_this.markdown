---
layout: post
title:  "js의 this에 대하여"
date:   2021-10-09 21:03:36 +0530
categories: Javascript
---

자바스크립트의 this에 대해서 정리해보고자 한다.

이는 YOU DON'T KNOW JS라는 책을 보고 정리한 글임을 밝힌다.

this가 어려운 이유
---

this가 어렵다고 느껴지는 이유는 우리가 dynamic하지 않은, static한 언어들의 컨셉에 더 익숙하기 때문이라 생각한다.

this는 dynamic하게 런타임에서 값이 바인딩된다.

다시 말해, 함수의 선언 위치가 중요한 것이 아니라, 이 함수를 어떻게 호출했느냐가 this에서 좀 더 중요한 부분이라는 뜻이다.

어떤 함수를 호출하면, 활성화 레코드, 즉 실행 컨텍스트가 만들어지는데, 이 부분에는

- call stack
- 호출 방법
- 전달된 인자
- this

이런 것들이 들어간다. this는 실제로 이 부분, 런타임에서 어떻게 불렸냐에 따라 충분히 달라질 수 있는 부분이다.

this의 값이 결정되는 규칙
---

### 첫번째 규칙 - 기본바인딩

가장 평범한 함수 호출인 단독 함수 실행에 관한 규칙으로, 나머지 규칙에 해당하지 않을 경우 적용되는 this의 기본 규칙이다.

``` javascript
functon foo(){
	console.log(this.a)
}
var a = 2;

foo(); // 2
```

전역 스코프에 변수를 선언하면 변수명과 같은 이름의 전역 객체 프로퍼티가 생성된다.

기본 바인딩은 strict 모드일때에는 undefined를, 아닐때에는 전역객체가 this의 대상으로 삼는다.

기본바인딩임을 아는 방법은, 앞으로 적을 나머지 규칙에 포함되지 않으면 된다. 지금은 지극히 평범한, 있는 그대로의 함수 레퍼런스를 호출했기 때문에, 나머지 규칙에 포함될 껀덕지도 없다.

### 두번째 규칙 - 암시적 바인딩

두번째 규칙에 속하는지의 여부는 호출부에 context 객체가 있는지, 객체의 소유/포함 여부를 확인해보면 알 수 있다.

``` javascript
function foo(){
	console.log(this.a)
}
var obj = {
	a: 2,
	foo: foo
}
obj.foo(); //2
```

obj이전에 선언한 foo 함수를 obj에서 프로퍼티로 참조하고 있다.

함수 레퍼런스에 대한 콘텍스트 객체가 존재할 때, 암시적 바인딩의 규칙에 따르면 이 콘텍스트 객체가 함수 호출 시 this에 바인딩 된다.

메서드 체이닝이 될 경우, 최상위/ 최하위 수준의 정보만 호출부와 연관된다.

### 암시적 소실

obj.foo를 다른 변수에 대입했을 경우,

``` javascript
var bar = obj.foo;
bar();
```

이처럼 bar에 대입하고, 그것을 호출했을 경우 암시적 소실이 일어난다.

이는 obj.foo는 obj에 앞서 선언했던 foo의 레펴런서를 bar라는 변수에 넘겨준것. 그 뿐이기 때문에, bar가 호출되는 시점에, 실제로 들고 있는 정보에는 obj의 context객체가 포함되지 않기 때문이다.

콜백 함수를 전달하는 경우엔 좀 더 애매하다.

``` javascript

function foo(){
	console.log(this.a)
}
function doFoo(fn){
	fn();
}
var obj = {
	a:2,
	foo:foo
}
var a = "전역"
doFoo(obj.foo);
```

인자로 전달한다는 것은, 일종의 암시적인 할당이다.

``` javascript
doFoo(fn) === doFoo(fn = obj.foo)
```

따라서 doFoo의 fn에 obj.foo가 가지고 있던, foo의 레퍼런스가 전달되는 것이기 때문에, fn을 통해 호출된 foo는 전역객체 this를 가진다.

이처럼 함수를 타고 타고 타고 들어가다보면, this가 이상한 값으로 되는 경우가 많다. 심지어 어떤 자바스크립트의 라이브러리의 이벤트 처리기를 보면, 우리가 작성한 콜백의 this가 이벤트를 유발한 DOM요소를 가리키도록 강제하는 경우도 있다고 한다.

이렇게 사라져버리는 this를 고정해서 사용하는 방법이 3번째 규칙이다.

### 3번째 규칙 명시적 바인딩

3번째 방법은 함수 레퍼런스 프로퍼티를 객체에 더하지 않고
``` javascript
// 함수 레퍼런스 프로퍼티를 객체에 더한다.
var obj={
	foo : foo
}
```

어떤 객체를 this 바인딩에 이용하겠다는 의지를 코드에 명확히 밝히는 방법이다.

이럴 때 사용할 수 있는, 모든 자바스크립트 함수가 함께 사용할 수 있는 아주 적당한 유틸리티가 있는데, 바로 call와 apply 메서드이다.

이 두 메서드는 this에 바인딩 할 객체를 첫번째 인자로 받아서 함수 호출 시 이 객체를 this로 세팅한다. this를 지정한 객체로 직접 바인딩하므로, 명시적 바인딩이라고 한다.

``` javascript
// foo라는 함수에서 사용할 this를 obj로 바인딩한다.
var obj = {
	a:2
}
foo.call(obj)
```

객체 대신 단순 primitive value를 인자로 전달하면, 원시 값에 대응되는 객체(new String()...)으로 매핑된다. 이 과정을 박싱이라고 한다.

하지만 이렇게 해도 앞서 암시적 바인딩의 문제였던 this 바인딩이 도중에 소실되거나 프레임워크가 임의로 덮어써 버리는 문제는 해결할 수 없다.

### 하드 바인딩

명시적 바인딩을 이용한 약간의 꼼수다.

``` javascript
var bar = function(){
	foo.call(obj);
}
setTimeout(bar, 100); //2
```

bar내부에서 foo.call(obj)를 호출함으로써, obj를 반드시 this에 강제로 바인딩하도록 하드 코딩한다. bar를 어떤 방식으로 호출하든, 이 함수는 obj를 바인딩해서 foo를 반드시 실행시킨다.  이런 바인딩은 명시적이고 강력해서 하드 바인딩이라고 불린다.

하드 바인딩은 인자를 넘기고 반환값을 돌려받는 창구가 필요할 때 주로 쓰인다.
``` javascript
function bind(fn, obj) {
	return function(){
		return fn.apply(obj, arguments);
	}
}
```

위처럼 바인드 헬퍼 함수를 사용하기도 한다.

하드 바인딩은 매우 자주 쓰이는 패턴이라서 ES5 내장 유틸리티 Function.prototype.bind 역시 이처럼 구현되어있다.

많은 라이브러리 함수와 자바스크립트 언어 및 호스트 환경에 내장된 여러 함수들은 대게 context라 불리는 선택적 인자를 제공한다. 이는 bind()를 써서 콜백 함수의 this를 지정할 수 없는 경우를 대비한 일종의 예비책이다.

### 4번째 규칙 : new 바인딩

함수 앞에 new를 붙여 생성자 호출을 하면 다음과 같은 일들이 일어난다.
- 새 객체가 만들어진다.
- new 함수가 자신의 또 다른 객체를 반환하지 않는 한, new와 함께 호출된 함수는 이 새 객체를 반환한다.
- 새로 생성된 객체는 해당 함수 호출 시 this로 바인딩 된다.
- 새로 생성된 객체의 [[ProtoType]]이 연결된다.

``` js
function foo(a){
	this.a = a;
}
var bar = new foo(2);
console.log(bar.a) //2
```

new를 붙여 foo를 호출했고, 새로 생성된 객체는 foo호출 시 this에 바인딩된다.

따라서 결국 new는 함수 호출 시 this를 새 객체와 바인딩하는 방법이며 이것이 new 바인딩이다.

