---
layout: post
title: react의 리팩토링에 대하여
date: 2021-10-10 00:00:00 +0930
categories: Javascript react
---

리액트 리팩토링 이야기

현재 진행중인 프로젝트에서 프론트엔드를 주로 맡고 있다. 프로젝트를 처음 진행하는 것이라, 책의 프로젝트 구조를 따왔고, 많은 초기 코드를 책에서 가져왔다.

## 리액트를 다루는 기술

이라는 책에서 가져왔는데, 리액트 훅, 리덕스 등 다양한 기술을 쓰고 있어서 마음에 들었었다.

redux를 사용함으로써 container와 component라는 구조를 이용하였고, Presentational and Container Pattern이라는 이름이 있는 리액트의 패턴이었다.

이 패턴을 사용하면, 리덕스 등 실제 데이터와 비즈니스 로직이 들어가는 부분은 컨테이너에, 오로지 view만을 담당하는 놈들은 컴포넌트에 작성함으로써,

실제 값이 들어가야하는 부분과 컴포넌트에 작성해야하는 부분의 분리가 된다는 장점을 갖는다.

하지만, 코드를 작성하다보니 꽤나 큰 문제가 있음이 다가왔는데 그 문제는 다음과 같다.

이 패턴을 작성하기 위해 나는 component, container, page라는 단위로 나눠서 프로그램을 작성했다.

component로 뷰를 만들고, container로 비즈니스 로직을 넣고 이 container들을 모아서 page를 만들어야지! 라는 생각이었다.

이론상 완벽하다 생각했다... 하지만, 코드를 작성하던 중, 이 패턴이 뭔가 잘못되어 가고 있음을 느꼈다.

잘못된 점은 다음과 같다.

1. component의 크기가 애매모호하다.

    리액트는 기본적인 사상이 작은 컴포넌트들을 모아서 큰 페이지를 구성한다. 라는 개념이 강하다 느꼈다.

    하지만, 컴포넌트의 크기를 정해둔 규칙 없이 작성하다보니, 시간에 쫒겨서 프로젝트를 짜다보면, 컴포넌트들의 크기가 매우 들쭉 날쭉한 상황이 자주 발생했다.

    코드가 망가지기 시작한 것이다.

2. component와 container의 관계가 애매해질때가 있다.

    "component와 container는 반드시 1대1 관계가 된다" 라는 규칙을 내 마음속에 암묵적으로 가져갔던 것 같다.

    이러다보니, 굉장히 큰 문제가 생겼는데, 크기가 큰 component에서 작은 container를 불러야하는 요상한 관계가 생겨버린 것이다.

    videoGridComponent : videoGird를 관리하는 component

    이 컴포넌트에서는 비디오 그리드를 보여주는 view를 관리하고자 했고, grid를 그리기 위해 각각의 video Item이 필요했는데, 이를 컨테이너로 가져와야 말이 되는것이다.

    뭐 상관 없다! 라고 단정짓고 프로젝트를 진행했었다.

3. 리덕스는 일단 전역변수다.

    리덕스가 중앙 state를 관리해줌으로써, 상태를 단방향이 아닌, 모든 곳에서 같은 상태를 가져올 수 있다. 굉장히 편하고, 내 프로그램이 유연해질 수 있다는 점에는 동의한다.

    하지만, 프로그래머의 마약이라고 불리는 전역변수와 같다는 느낌을 프로젝트를 진행하면 진행할수록 느꼈다.

    심지어 리덕스를 사용하면 어쩌면 짧게 끝낼 수 있는 것도 굉장히 많은 코드를 작성해야 했기 때문에, 모든 곳에서 사용하기 보다는 꼭 중앙 state가 필요한 시점에만 사용하는것이 맞겠다라는 생각이 들었다.

4. 혼자하는 프로젝트가 아니다.

    사실 혼자하는 프로젝트라면, 컴포넌트의 크기가 들쭉날쭉하든, 리덕스를 사용하든, 관계가 애매하든, 리팩토링을 하려는 마음도 그렇게 크지 않았을지도 모른다.

    하지만, 나 뿐 아니라 여러명이 하고 있는 프로젝트에서 코드의 readability가 매우 중요함을 느끼게 되었다.

    나 뿐 아니라 다른 프로젝트 팀원도 리덕스, 리덕스 사가, 리덕스 툴킷 같은 리덕스 관련 라이브러리를 알아야 한다는 것은 리덕스를 모르는 팀원의 readability를 매우 낮췄다.

    심지어 redux toolkit은 리덕스의 중복되는 코드를 미친듯이 추상화하여 사용하기 때문에, 모른다면 읽을 수 없는 코드가 되어버린다.

    또한, 이전에 말했던 컨테이너와 컴포넌트의 애매모호한 관계들은 팀원들이 프론트의 코드를 바로 이해할 수 없게 만드는데 일조했다.

## 이 문제를 어떻게 타개할 것인가?

어떻게 코드의 구조를 바른 길로 만들어야하는가에 대해 고민해보았고, 방법은 다음과 같다.

1. atomic design을 사용한다.

    처음 봤을 때 atomic design은 어쩌면 리액트에 가장 맞는 구조일지도 모르겠다. 라는 생각이 들었었다.

    ![atomicDesign](/assets/img/1010/atomicDesign.png)

    작은 atom을 molecule로 묶고, 그 molecule을 묶어서 organism으로 만들고, 그것을 묶어 template을 만든다.

    그리고 이 템플릿에 비즈니스 로직을 넣으면, page가 된다.

    그리고 이들의 기준은 다음과 같을 예정이다.

    - atom : 버튼과 같은 정말 작은 하나의 단위.
    - molecule : atom들이 모여있지만, width가 100%가 아닌 놈들.
    - organism : atom과 molecule들을 모아 width가 100%인 놈. 예) navbar
    - template : organism들을 모아서 템플릿을 만든다.
    - page : 이제서야 비즈니스 로직을 넣는다.

    이를 통해 모든 비즈니스 로직이 page에 모여있고, 이전과 비교해봤을 때 기준이 명확해진 코드를 작성할 수 있을 것 같다.

    또한, 이전의 많았던 리덕스 코드를 어느정도 없앨 수 있을 것 같다.

2. class를 적극적으로 사용한다.

    class를 사용해서 api call들을 묶어주는 모습을 본 적이 있다.

    내 코드는 그것에 비해 그저 내가 필요할 때 axios call을 해서 가져오는 것이었고, 이는 그런 코드에 비해 매우 나빠보였다.

    class를 통해 api call들에 추상화를 걸어 로직들을 숨기고 readability를 높이는 모습은 매우 인상깊었다. 한번 해보고 싶다.

3. dependency injection을 사용한다.

    class 코드를 사용하는 과정에서, api call을 담당하는 class들을 계속 new를 통해 객체를 새로 만들어내는 방법은 좋지 않다는 것을 배웠다.

    효율성 면에서 굉장히 떨어지는 방법이다.

    index.tsx에서 그런 객체를 모두 만든 후, app.tsx로 injection을 해주면, 객체를 한번만 만들고도 모든 컴포넌트에서 똑같은 객체를 사용할 수 있다.

## 이제 구현

이제 구현을 해야한다.

이전의 구조와 현재의 구조를 생각해보면, 코드의 대대적인 개편이 필요한 상황이다.

이것이 과연 앞으로의 프로젝트에 효율적일것인가에 대해 생각해봐야한다.

이 프로젝트가 어떻게되든, 앞으로 게시판, 채팅 등 붙여나가고 싶은 서비스들이 굉장히 많다. 앞으로 붙을 서비스들을 위해서라도, 지금이 아니면 나중에 좀 더 힘들것이다라는것이 내 결론이다.

쉽지 않겠지만 해봐야겠다.

-   api call 서비스 객체로 묶기
-   app.tsx에 dependency 만들기
-   프로젝트들 나눠서 구조잡기
-   구조로 프로그래밍
